import 'dart:convert';

import 'package:flutter_test/flutter_test.dart';
import 'package:provenance_dart/wallet.dart';

const phrase =
    "dance net yard verb mosquito face cliff close pig diesel popular shuffle scrap minimum honey broccoli scatter shrug squirrel jump hello rally achieve later";

final seed = List<int>.unmodifiable(Mnemonic.createSeed(phrase.split(" ")));

// NOTE: account information for the various chains was generated by https://iancoleman.io/bip39/#english

class _PrivateKeyMatcher extends Matcher {
  final PrivateKey privateKey;
  final bool blankChainCode;

  _PrivateKeyMatcher(this.privateKey, [this.blankChainCode = false]);

  @override
  bool matches(dynamic item, Map matchState) {
    final pKeyArg = item as PrivateKey;
    expect(pKeyArg.coin, privateKey.coin);
    expect(pKeyArg.raw, privateKey.raw);
    if (blankChainCode) {
      expect(pKeyArg.chainCode, List<int>.filled(32, 0));
    } else {
      expect(pKeyArg.chainCode, privateKey.chainCode);
    }
    return true;
  }

  @override
  Description describe(Description description) => description;
}

main() {
  test("forChainId", () {
    expect(Coin.forChainId("pio-testnet-1"), Coin.testNet);
    expect(Coin.forChainId("pio-mainnet-1"), Coin.mainNet);
    expect(() => Coin.forChainId("Invalid"), throwsStateError);
  });

  group("DerivationNode", () {
    test("path string is properly converted to a list of derivation nodes", () {
      expect(DerivationNode.fromPathString("m/44'/1'/0'/0/0'"), const [
        DerivationNode.hardened(44),
        DerivationNode.hardened(1),
        DerivationNode.hardened(0),
        DerivationNode.notHardened(0),
        DerivationNode.hardened(0),
      ]);

      expect(DerivationNode.fromPathString("m/44'/61'/0'/0"), const [
        DerivationNode.hardened(44),
        DerivationNode.hardened(61),
        DerivationNode.hardened(0),
        DerivationNode.notHardened(0),
      ]);

      expect(DerivationNode.fromPathString("m/44'"), const [
        DerivationNode.hardened(44),
      ]);
    });

    test("path strings must start with m and use apostraphe", () {
      expect(() => DerivationNode.fromPathString("M/44'/1'/0'/0/0'"),
          throwsException);
      expect(() => DerivationNode.fromPathString("/44'/1'/0'/0/0'"),
          throwsException);
      expect(() => DerivationNode.fromPathString(""), throwsException);
    });
  });

  group("testNet", () {
    final privKey = PrivateKey.fromSeed(seed, Coin.testNet);

    test("defaultKey", () {
      expect(privKey.defaultKey().rawHex,
          "734c404398f9109f8b94810537a295ae7801a871f4b22d2796630f272001acaf");
    });

    test("private key is properly created from hex String", () {
      final pk = PrivateKey.fromPrivateKey(privKey.rawHex, privKey.coin);
      expect(pk, _PrivateKeyMatcher(privKey, true));
    });

    test("The private key can be recovered from the serialized string", () {
      var bip32 = privKey.serialize(publicKeyOnly: false);
      expect(PrivateKey.fromBip32(bip32), _PrivateKeyMatcher(privKey));

      bip32 = privKey.serialize(publicKeyOnly: true);
      expect(() => PrivateKey.fromBip32(bip32), throwsException);
    });

    test("serialized key", () {
      expect(privKey.serialize(publicKeyOnly: false),
          "tprv8ZgxMBicQKsPcxwubvCqvjVsXHpRU9qy3bFk9BndAd9ixe78B7dG5LBwrHisVgoqqa1A2sdoyT9Sm9FWJ9xD26FQzwNjY5nEbSa7gBNegEs");
      expect(privKey.serialize(publicKeyOnly: true),
          "tpubD6NzVbkrYhZ4WRyhVZsSL99z6KLMdV2sctrXRhpvatx7o8MtoWSrFpop2TiqpopyUtWywycRjBmfYkUEZQRXmi5xqq1wzkEtVCG6a2eU9aS");
      expect(privKey.serialize(),
          "tpubD6NzVbkrYhZ4WRyhVZsSL99z6KLMdV2sctrXRhpvatx7o8MtoWSrFpop2TiqpopyUtWywycRjBmfYkUEZQRXmi5xqq1wzkEtVCG6a2eU9aS");
    });

    test("public Key", () {
      final publicKey = privKey.defaultKey().publicKey;

      expect(publicKey.coin, privKey.coin);
      expect(publicKey.compressedPublicKeyHex,
          "03cd26c1612a0536c4d7d5f7324c80209ffd23af7619be81a27e994e5a9426dac0");
      expect(publicKey.address, "tp1k3zh5ak5xcx0pfq3lynnw0lejnhhrlgfwy33xl");
    });

    test("depth matches number of derivations", () {
      const path = [
        DerivationNode.notHardened(1),
        DerivationNode.notHardened(3),
        DerivationNode.notHardened(4),
      ];
      var pKey = privKey;

      expect(privKey.index, 0);
      expect(privKey.depth, 0);

      for (int index = 0; index < path.length; index++) {
        pKey = pKey.derived(path[index]);
        expect(pKey.depth, index + 1);
        expect(pKey.index, path[index].index);
      }
    });

    test("signData generates valid signature", () {
      final sig = privKey.signData("A Test String".codeUnits);
      expect(base64Encode(sig),
          "29BFmtk6ByqCi3yZmhGP4fBV9cYE0imb0IDvZ7UDKUowaMm7JpyWX/F8MenpqlCFjcl878Wd+I2oDwd/RQiR5QE=");
    });

    test("signText generates valid signature", () {
      final sig = privKey.signText("A Test String");
      expect(base64Encode(sig),
          "cTNMFO+FotCxCwY9raUHcBNANpv6RT5rsqCvPRhEeGNgqDTQMkso8r0Nq64cJT2V1UqfbIePsQNcRTzbQlvi0gE=");
    });
  });

  group("mainNet", () {
    final privKey = PrivateKey.fromSeed(seed, Coin.mainNet);

    test("defaultKey", () {
      expect(privKey.defaultKey().rawHex,
          "a65972345d5c7cec342ef951c211094ba199fe9696657d10decc02a1958ef8da");
    });

    test("private key is properly created from hex String", () {
      final pk = PrivateKey.fromPrivateKey(privKey.rawHex, privKey.coin);
      expect(pk, _PrivateKeyMatcher(privKey, true));
    });

    test("The private key can be recovered from the serialized string", () {
      var bip32 = privKey.serialize(publicKeyOnly: false);
      expect(PrivateKey.fromBip32(bip32), _PrivateKeyMatcher(privKey));

      bip32 = privKey.serialize(publicKeyOnly: true);
      expect(() => PrivateKey.fromBip32(bip32), throwsException);
    });

    test("serialized key", () {
      expect(privKey.serialize(publicKeyOnly: false),
          "xprv9s21ZrQH143K29iNwMMLm5stDAQDEdoxi3LdGmNAgefFB3N3BkHWZapVw7ZDVKRXU8UP2n23p6ZeJHhmAwcGD2ypUJARsj4BgLphEYHNkMp");
      expect(privKey.serialize(publicKeyOnly: true),
          "xpub661MyMwAqRbcEdnr3NtM8DpcmCEhe6Xp5GGE59mnEzCE3qhBjHbm7P8ynRe4JJsjgyz5LQ6ZC5wcrZydAYaHtGdfnEGeKDaeuEfgp1eWWTQ");
      expect(privKey.serialize(),
          "xpub661MyMwAqRbcEdnr3NtM8DpcmCEhe6Xp5GGE59mnEzCE3qhBjHbm7P8ynRe4JJsjgyz5LQ6ZC5wcrZydAYaHtGdfnEGeKDaeuEfgp1eWWTQ");
    });

    test("public Key", () {
      final publicKey = privKey.defaultKey().publicKey;

      expect(publicKey.coin, privKey.coin);
      expect(publicKey.compressedPublicKeyHex,
          "02cf3b864c4ae245dc78c909415fb12ee3ca12e3cece402b43d685beffd711425d");
      expect(publicKey.address, "pb1z8tn7hslpp6exye4fd8sxy58wwk0urnhwc3rcg");
    });

    test("depth matches number of derivations", () {
      const path = [
        DerivationNode.notHardened(1),
        DerivationNode.notHardened(3),
        DerivationNode.notHardened(4),
      ];
      var pKey = privKey;

      expect(privKey.index, 0);
      expect(privKey.depth, 0);

      for (int index = 0; index < path.length; index++) {
        pKey = pKey.derived(path[index]);
        expect(pKey.depth, index + 1);
        expect(pKey.index, path[index].index);
      }
    });

    test("signData generates valid signature", () {
      final sig = privKey.signData("A Test String".codeUnits);
      expect(base64Encode(sig),
          "29BFmtk6ByqCi3yZmhGP4fBV9cYE0imb0IDvZ7UDKUowaMm7JpyWX/F8MenpqlCFjcl878Wd+I2oDwd/RQiR5QE=");
    });

    test("signText generates valid signature", () {
      final sig = privKey.signText("A Test String");
      expect(base64Encode(sig),
          "cTNMFO+FotCxCwY9raUHcBNANpv6RT5rsqCvPRhEeGNgqDTQMkso8r0Nq64cJT2V1UqfbIePsQNcRTzbQlvi0gE=");
    });
  });
}
